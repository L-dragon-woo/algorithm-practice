# algorithm-practice
---
### 에라토스테네스의 체(Sieve of Eratosthenes)
> 특정 범위 내에서 쉽게 소수 판정

소수(prime number): 1과 자기 자신의 반수로 밖에 나누어 떨어지지 않는 1 이외의 정수, **즉 양의 약수가 2개인 자연수 혹은 정수**
-막무가내로 정수 N에서 소수인지 판별하려고 하면 N개의 수에서 2의 배수 빼고 3의 배수 빼고 ...이런 방식을 반복할 것이다.
하지만 **에라토스테네스의 체**를 활용하면 이런 방식을 사용하지 않는다.

만약 n보다 작은 어떤 수 m이 m=ab라면 a와 b중 적어도 하나는 √n이하이다. **즉 n보다 작은 합 성수 m은 √n보다 작은 수의 배수만 체크해도 전부 지워진다는 의미!!**

#### 하지만 이것은 특정 범위 내의 소수를 만정하는 데에만 효율적임!! 


---

### 유클리드 호제법(Euclidean algorithm)
>두 양의 정수 혹은 두 다항식의 최대공약수 구하기

두 양의 정수 a,b(a>b)에 대하여 a=bq+r(0<=r<b)이라 하면 a,b의 최대공약수는 b,r의 최대공약수와 같다.
**즉, gcd(a,b)=gcd(b,r)** 여기서 만약 r=0이면 a,b의 최대공약수는 b가 된다.

*참고로 두 정수 a,b의 최소공배수는  a * b / 최대공약수*

보통은 나머지가 0이 될때까지 연속해서 사용한다.

ex) 2484와 4212의 최대 공약수 구하기
```
4212=2484 * 1 + 1728
2484=1728 * 1 + 756
1728=756 * 2 + 216
756=216 * 3 + 108
216=108 * 2
따라서 두 수의 최대공약수는 108
```
---
### HashMap
> HashMap의 한계

HashMap은 일단 자바에서 키(key)와 값(Value)쌍을 저장하는 자료 구조를 뜻하고 이 키(key)는 고유하고 키를 사용하여 해당하는 값을 빠르게 검색 가능하다

**hashMap의 특징**
1. 키를 기반한 빠른 액세스(시간 복잡도가 O(1)이다)
2. 순서를 보장하지 않는다.(**왜냐면 내부적으로 키의 순서를 보장하지 않는다**)
3. 키의 중복이 불가능하다.(HashMap의 특성상 이미 존재하는 키에 대해 값을 저장하면 기존 값이 덮어씌워진다. 또한 key로 값을 찾는것이므로 같은 키를 갖는 여러 value가 존재할 수 없다.)
4. 키 기반의 유연성 : 어떤 객체든 키로 사용할 수 있다.
5. 해싱 충돌: 두 개 이상의 키가 동일한 해시 코드를 가질 때 충돌이 발생한다.

<img width="1326" height="784" alt="Image" src="https://github.com/user-attachments/assets/3f11afa9-a033-47d4-a53f-03416308ac20" />


   




